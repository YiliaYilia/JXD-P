// Clearfix
.clearfix() {
  &:before,
  &:after {
    content: " "; // 1
    display: table; // 2
  }
  &:after {
    clear: both;
  }
  *min-height: 1% ;
}

//inline-block
.inline-block(){
	display:inline-block;
	
	//fix ie7
	*zoom:1;
	*display:inline;
}


.hide-text() {
  font: ~"0/0" a;
  color: transparent;
  text-shadow: none;
  background-color: transparent;
  border: 0;
}
// New mixin to use as of v3.0.1
.text-hide() {
  .hide-text();
}

// Center-align a block level element
.center-block() {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

////grid
//// Generate the extra small columns
//.make-column(@columns) {
//  position: relative;
//  float: left;
//  width: percentage((@columns / @grid-columns));
//  // Prevent columns from collapsing when empty
//  min-height: 1px;
//}
//
//.make-grid-columns() {
//  // Common styles for all sizes of grid columns, widths 1-12
//  .col(@index) when (@index = 1) { // initial
//    @item: ~".col-@{index}";
//    .col(@index + 1, @item);
//  }
//  .col(@index, @list) when (@index =< @grid-columns) { // general; "=<" isn't a typo
//    @item: ~".col-@{index}";
//    .col(@index + 1, ~"@{list}, @{item}");
//  }
//  .col(@index, @list) when (@index > @grid-columns) { // terminal
//    @{list} {
//      position: relative;
//      // Prevent columns from collapsing when empty
//      min-height: 1px;
//      // Inner gutter via padding
//    }
//  }
//  .col(1); // kickstart it
//}
//
//
//.calc-grid(@index, @type) when (@type = width) and (@index > 0) {
//  .col-@{index} {
//    width: percentage((@index / @grid-columns));
//  }
//}
//
//.calc-grid(@index, @type) when (@type = width) and (@index = 12) {
//  .col-@{index} {
//  	width: percentage((@index / @grid-columns));
//    width:49.99999%\0;
//  }
//}
//
//.calc-grid(@index, @type) when (@type = push) {
//  .col-push-@{index} {
//    left: percentage((@index / @grid-columns));
//  }
//}
//.calc-grid(@index, @type) when (@type = pull) {
//  .col-pull-@{index} {
//    right: percentage((@index / @grid-columns));
//  }
//}
//.calc-grid(@index, @type) when (@type = offset) {
//  .col-offset-@{index} {
//    margin-left: percentage((@index / @grid-columns));
//  }
//}
//
//// Basic looping in LESS
//.make-grid(@index, @type) when (@index >= 0) {
//  .calc-grid(@index, @type);
//  // next iteration
//  .make-grid(@index - 1, @type);
//}
//
//.make-grid-columns-float() {
//  .col(@index) when (@index = 1) { // initial
//    @item: ~".col-@{index}";
//    .col(@index + 1, @item);
//  }
//  .col(@index, @list) when (@index =< @grid-columns) { // general
//    @item: ~".col-@{index}";
//    .col(@index + 1, ~"@{list}, @{item}");
//  }
//  .col(@index, @list) when (@index > @grid-columns) { // terminal
//    @{list} {
//      float: left;
//    }
//  }
//  .col(1); // kickstart it
//}


// Generate the extra small columns
.make-xs-column(@columns; @gutter: @grid-gutter-width) {
  position: relative;
  float: left;
  width: percentage((@columns / @grid-columns));
  // Prevent columns from collapsing when empty
  min-height: 1px;
  // Inner gutter via padding
  padding-left:  (@gutter / 2);
  padding-right: (@gutter / 2);
}

// Generate the small columns
.make-sm-column(@columns; @gutter: @grid-gutter-width) {
  position: relative;
  // Prevent columns from collapsing when empty
  min-height: 1px;
  // Inner gutter via padding
  padding-left:  (@gutter / 2);
  padding-right: (@gutter / 2);

  // Calculate width based on number of columns available
  @media (min-width: @screen-sm-min) {
    float: left;
    width: percentage((@columns / @grid-columns));
  }
}

// Generate the small column offsets
.make-sm-column-offset(@columns) {
  @media (min-width: @screen-sm-min) {
    margin-left: percentage((@columns / @grid-columns));
  }
}
.make-sm-column-push(@columns) {
  @media (min-width: @screen-sm-min) {
    left: percentage((@columns / @grid-columns));
  }
}
.make-sm-column-pull(@columns) {
  @media (min-width: @screen-sm-min) {
    right: percentage((@columns / @grid-columns));
  }
}

// Generate the medium columns
.make-md-column(@columns; @gutter: @grid-gutter-width) {
  position: relative;
  // Prevent columns from collapsing when empty
  min-height: 1px;
  // Inner gutter via padding
  padding-left:  (@gutter / 2);
  padding-right: (@gutter / 2);

  // Calculate width based on number of columns available
  @media (min-width: @screen-md-min) {
    float: left;
    width: percentage((@columns / @grid-columns));
  }
}

// Generate the medium column offsets
.make-md-column-offset(@columns) {
  @media (min-width: @screen-md-min) {
    margin-left: percentage((@columns / @grid-columns));
  }
}
.make-md-column-push(@columns) {
  @media (min-width: @screen-md) {
    left: percentage((@columns / @grid-columns));
  }
}
.make-md-column-pull(@columns) {
  @media (min-width: @screen-md-min) {
    right: percentage((@columns / @grid-columns));
  }
}

// Generate the large columns
.make-lg-column(@columns; @gutter: @grid-gutter-width) {
  position: relative;
  // Prevent columns from collapsing when empty
  min-height: 1px;
  // Inner gutter via padding
  padding-left:  (@gutter / 2);
  padding-right: (@gutter / 2);

  // Calculate width based on number of columns available
  @media (min-width: @screen-lg-min) {
    float: left;
    width: percentage((@columns / @grid-columns));
  }
}

// Generate the large column offsets
.make-lg-column-offset(@columns) {
  @media (min-width: @screen-lg-min) {
    margin-left: percentage((@columns / @grid-columns));
  }
}
.make-lg-column-push(@columns) {
  @media (min-width: @screen-lg-min) {
    left: percentage((@columns / @grid-columns));
  }
}
.make-lg-column-pull(@columns) {
  @media (min-width: @screen-lg-min) {
    right: percentage((@columns / @grid-columns));
  }
}


// Framework grid generation
//
// Used only by Bootstrap to generate the correct number of grid classes given
// any value of `@grid-columns`.

.make-grid-columns() {
  // Common styles for all sizes of grid columns, widths 1-12
  .col(@index) when (@index = 1) { // initial
    @item: ~".col-xs-@{index}, .col-sm-@{index}, .col-md-@{index}, .col-lg-@{index}";
    .col(@index + 1, @item);
  }
  .col(@index, @list) when (@index =< @grid-columns) { // general; "=<" isn't a typo
    @item: ~".col-xs-@{index}, .col-sm-@{index}, .col-md-@{index}, .col-lg-@{index}";
    .col(@index + 1, ~"@{list}, @{item}");
  }
  .col(@index, @list) when (@index > @grid-columns) { // terminal
    @{list} {
      position: relative;
      // Prevent columns from collapsing when empty
      min-height: 1px;
    }
  }
  .col(1); // kickstart it
}

.make-grid-columns-float(@class) {
  .col(@index) when (@index = 1) { // initial
    @item: ~".col-@{class}-@{index}";
    .col(@index + 1, @item);
  }
  .col(@index, @list) when (@index =< @grid-columns) { // general
    @item: ~".col-@{class}-@{index}";
    .col(@index + 1, ~"@{list}, @{item}");
  }
  .col(@index, @list) when (@index > @grid-columns) { // terminal
    @{list} {
      float: left;
    }
  }
  .col(1); // kickstart it
}

.calc-grid(@index, @class, @type) when (@type = width) and (@index > 0) {
  .col-@{class}-@{index} {
    width: percentage((@index / @grid-columns));
  }
}
.calc-grid(@index, @class, @type) when (@type = push) {
  .col-@{class}-push-@{index} {
    left: percentage((@index / @grid-columns));
  }
}
.calc-grid(@index, @class, @type) when (@type = pull) {
  .col-@{class}-pull-@{index} {
    right: percentage((@index / @grid-columns));
  }
}
.calc-grid(@index, @class, @type) when (@type = offset) {
  .col-@{class}-offset-@{index} {
    margin-left: percentage((@index / @grid-columns));
  }
}

// Basic looping in LESS
.make-grid(@index, @class, @type) when (@index >= 0) {
  .calc-grid(@index, @class, @type);
  // next iteration
  .make-grid(@index - 1, @class, @type);
}





.input-disable(){
	.input-readonly();
}
.input-readonly(){
	border:1px solid #ddd;
	background-color:#fafafa;
}
.input-error(){
	border:1px solid #F6171F;
	background-color:#FEF2F2;
}

.fullscreen(){
	position:absolute;
	top:0;
	left:0;
	height:100%;
	width:100%;
}
.fullwidth(){
	position:absolute;
	width:100%;
}